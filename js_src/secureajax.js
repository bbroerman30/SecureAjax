function bbSecureAjaxLayer() {
	// used for internal methods, as the this pointer may not always work in JavaScript.
	var that=this;

	// The server's public RSA key. We don't need a client key as this key is generated
	// for each session. 
	var serverPublicKey={ exp:"<?php print($rsaKey['public']) ?>",
		                  mod:"<?php print($rsaKey['mod']) ?>"};


	// Diffie-Hellman key exchange. This is the challenge generated by the server. It is
	// used in the init method to generate the AES key for the session.
	var diffieHellman={ gen:"<?php print($dhKeys['gen']) ?>",
			            mod:"<?php print($dhKeys['mod']) ?>",
			            msg:"<?php print($dhKeys['message']) ?>" };

	// random AES key used to decode the second set of scripts. Only used for that 1 transaction.
	var scriptDecodeKey="<?php print($_SESSION['HELPER_SCRIPT_ENDODING_KEY']) ?>";

	var serverURL="<?php print($secureAjaxConfig['APIBASEURL']);?>";

	// callback function passed in by the login method (SecureAjaxLogin class) that is
	// called when the SecureAjaxLayer is initialized. Member method due to the use of
	// a timer on the DH key generation.
	var channelReadyCallbackFn=null;

	// Session AES key.
	var sharedSecretKey=null; 

	// Used in the public API to indiate that the class is ready. This is used to hide
	// the internal codes from prying eyes.
	var DHNegotiationInProgress=true;

	// tracks scripts that are dependent on other scripts, and ensures they are executed in order.
	var scriptDependencyCache=new Array();

	// AES Javascript library Copyright Chris Veness 2005-2008. 
	// Right of free use is granted for all.
	// see http://csrc.nist.gov/publications/PubsFIPS.html#197
	function bbSecureAjaxAESHelper() 
	{
		// Sbox is pre-computed multiplicative inverse in GF(2^8) used in SubBytes and KeyExpansion [§5.1.1]
		var Sbox=[99,124,119,123,242,107,111,197,48,1,103,43,254,215,171,118,202,130,201,125,250,89,
		          71,240,173,212,162,175,156,164,114,192,183,253,147,38,54,63,247,204,52,165,229,241,
		          113,216,49,21,4,199,35,195,24,150,5,154,7,18,128,226,235,39,178,117,9,131,44,26,27,
		          110,90,160,82,59,214,179,41,227,47,132,83,209,0,237,32,252,177,91,106,203,190,57,74,
		          76,88,207,208,239,170,251,67,77,51,133,69,249,2,127,80,60,159,168,81,163,64,143,146,
		          157,56,245,188,182,218,33,16,255,243,210,205,12,19,236,95,151,68,23,196,167,126,61,
		          100,93,25,115,96,129,79,220,34,42,144,136,70,238,184,20,222,94,11,219,224,50,58,10,
		          73,6,36,92,194,211,172,98,145,149,228,121,231,200,55,109,141,213,78,169,108,86,244,
		          234,101,122,174,8,186,120,37,46,28,166,180,198,232,221,116,31,75,189,139,138,112,62,
		          181,102,72,3,246,14,97,53,87,185,134,193,29,158,225,248,152,17,105,217,142,148,155,
		          30,135,233,206,85,40,223,140,161,137,13,191,230,66,104,65,153,45,15,176,84,187,22];

		// Rcon is Round Constant used for the Key Expansion [1st col is 2^(r-1) in GF(2^8)] [§5.2]          
		var Rcon=[[0,0,0,0],[1,0,0,0],[2,0,0,0],[4,0,0,0],
		          [8,0,0,0],[16,0,0,0],[32,0,0,0],[64,0,0,0],
		          [128,0,0,0],[27,0,0,0],[54,0,0,0]];

		// String used for the Base-64 encoder.
		var b64="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

		//
		// Encode string into Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
		// (instance method extending String object). As per RFC 4648, no newlines are added.  
		//
		// @param {String} a - The string to be encoded as base-64
		// @returns {String} Base64-encoded string
		// 
		String.prototype.encodeBase64 = function( a ) 
		{
			a=(typeof a=="undefined") ? false : a;
			var b, c, d, e, f, g, h, i, j = [], k = "", l, m, n;
			m = a  ? this.encodeUTF8() : this;
			l = m.length % 3;
			
			if( l > 0 ) 
			{
				while( l++ < 3 ) 
				{
					k+="=";
					m+="\x00";
				}
			}
			
			for(l = 0; l < m.length; l += 3) 
			{
				b = m.charCodeAt( l );
				c = m.charCodeAt( l+1 );
				d = m.charCodeAt( l+2 );
				e = b << 16 | c << 8 | d;
				f = e >> 18 & 63;
				g = e >> 12 & 63;
				h = e >> 6 & 63;
				i = e & 63;
				j[l/3] = b64.charAt( f ) + b64.charAt( g ) + b64.charAt( h ) + b64.charAt( i );
			}
			
			n = j.join( "" );
			n = n.slice( 0, n.length - k.length ) + k;
			
			return n;
		};

		//
		// Decode string from Base64, as defined by RFC 4648 [http://tools.ietf.org/html/rfc4648]
		// (instance method extending String object). As per RFC 4648, newlines are not catered for.
		//
		// @param {String} a - The string to be decoded from base-64
		// @returns {String} decoded string
		//
		String.prototype.decodeBase64 = function( a )
		{
			a = ( typeof a == "undefined" ) ? false : a;
			var b, c, d, e, f, g, h, i, j=[], k, l;
			l = a ? this.decodeUTF8() : this;
			
			for( var m = 0; m < l.length; m += 4 ) 
			{
				e = b64.indexOf( l.charAt( m ) );
				f = b64.indexOf( l.charAt( m + 1 ) );
				g = b64.indexOf( l.charAt( m + 2 ) );
				h = b64.indexOf( l.charAt( m + 3 ) );
				i = e << 18 | f << 12 | g << 6 | h;
				b = i >>> 16 & 255;
				c = i >>> 8 & 255;
				d = i & 255;
				
				j[m/4] = String.fromCharCode( b, c, d );
				
				if( h == 64 )
				{
					j[m/4] = String.fromCharCode( b, c );
				}
				
				if( g == 64 )
				{
					j[m/4] = String.fromCharCode( b );
				}
			}
			
			k = j.join( "" );
			
			return a ? k.decodeUTF8() : k;
		};

		//
		// Encode multi-byte Unicode string into utf-8 multiple single-byte characters 
		// (BMP / basic multilingual plane only)
		//
		// Chars in range U+0080 - U+07FF are encoded in 2 chars, U+0800 - U+FFFF in 3 chars
		//
		// @returns {String} encoded string
		//
		String.prototype.encodeUTF8 = function()
		{
			var a = this.replace( /[\u0080-\u07ff]/g, function( c ) 
			{
				var b = c.charCodeAt( 0 );
				return String.fromCharCode( 192 | b >> 6, 128 | b & 63 );
			} );

			a = a.replace( /[\u0800-\uffff]/g, function( c ) 
			{
				var b = c.charCodeAt( 0 );
				return String.fromCharCode( 224 | b >> 12, 128 | b >> 6 & 63, 128 | b & 63 );
			});

			return a;
		};

		//
		// Decode utf-8 encoded string back into multi-byte Unicode characters
		// 
		// @param {String} strUtf UTF-8 string to be decoded back to Unicode
		// @returns {String} decoded string
		//
		String.prototype.decodeUTF8 = function()
		{
			var a = this.replace( /[\u00c0-\u00df][\u0080-\u00bf]/g, function( c ) 
			{
				var b = ( c.charCodeAt( 0 ) & 31 ) << 6 | c.charCodeAt( 1 ) & 63;
				return String.fromCharCode( b );
			});
			
			a = a.replace( /[\u00e0-\u00ef][\u0080-\u00bf][\u0080-\u00bf]/g, function( c ) 
			{
				var b = ( ( c.charCodeAt( 0 ) & 15 ) << 12 ) | ( ( c.charCodeAt( 1 ) & 63 ) << 6 ) | ( c.charCodeAt( 2 ) & 63 );
				return String.fromCharCode( b );
			});
			
			return a;
		};

		//
		// AES Cipher function: encrypt 'input' state with Rijndael algorithm
		//   applies Nr rounds (10/12/14) using key schedule w for 'add round key' stage
		//
		// @param {Number[]} a    16-byte (128-bit) input state array
		// @param {Number[][]} w  Key schedule as 2D byte-array (Nr+1 x Nb bytes)
		// @returns {Number[]}    Encrypted output state array
		//
		function Cipher( a, w )
		{
			var b = 4;
			var c = w.length / b - 1;
			var d=[[],[],[],[]];
			
			for( var i = 0; i < 4 * b; i++ ) 
			{
				d[i%4][Math.floor(i/4)]=a[i];
			}
			
			d = AddRoundKey( d, w, 0, b );
			
			for( var e = 1; e < c; e++ ) 
			{
				d = SubBytes( d, b );
				d = ShiftRows( d, b );
				d = MixColumns( d, b );
				d = AddRoundKey( d, w, e, b );
			}
			
			d = SubBytes( d, b );
			d = ShiftRows( d, b );
			d = AddRoundKey( d, w, c, b );
			
			var f = new Array( 4 * b );
			for( var i = 0; i < 4 * b; i++ )
			{
				f[i] = d[i%4][Math.floor( i / 4 )];
			}
			
			return f;
		};

		// apply SBox to state S [§5.1.1]
		function SubBytes( s, a )
		{
			for( var r = 0; r < 4; r++ )
			{
				for( var c = 0; c < a; c++ )
				{
					s[r][c] = Sbox[s[r][c]];
				}
			}
			
			return s;
		};

		// shift row r of state S left by r bytes [§5.1.2]
		function ShiftRows( s, a )
		{
			var t = new Array( 4 );
			
			for( var r = 1; r < 4; r++ ) 
			{
				for( var c = 0; c < 4; c++ )
				{
					t[c] = s[r][( c + r ) % a];
				}
				for( var c = 0; c < 4; c++ ) 
				{
					s[r][c] = t[c];
				}
			}
			
			return s;
		};


		// combine bytes of each col of state S [§5.1.3]
		function MixColumns( s, a )
		{
			for( var c = 0; c < 4; c++ )
			{
				var b = new Array(4);
				var d = new Array(4);
				
				for( var i = 0; i < 4; i++ )
				{
					b[i] = s[i][c];
					d[i] = s[i][c] & 128 ? s[i][c] << 1^283 : s[i][c] << 1;
				}
				
				s[0][c] = d[0] ^ b[1] ^ d[1] ^ b[2] ^ b[3];
				s[1][c] = b[0] ^ d[1] ^ b[2] ^ d[2] ^ b[3];
				s[2][c] = b[0] ^ b[1] ^ d[2] ^ b[3] ^ d[3];
				s[3][c] = b[0] ^ d[0] ^ b[1] ^ b[2] ^ d[3];
			}
			
			return s;
		};

		// xor Round Key into state S [§5.1.4]
		function AddRoundKey( a, w, b, c )
		{
			for( var r = 0; r < 4; r++ )
			{
				for( var d = 0; d < c; d++ )
				{
					a[r][d] ^= w[b*4+d][r];
				}
			}
			
			return a;
		};

		//
		// Perform Key Expansion to generate a Key Schedule
		//
		// @param {Number[]} a    Key as 16/24/32-byte array
		// @returns {Number[][]}  Expanded key schedule as 2D byte-array ( d x c bytes)    
		//
		function KeyExpansion( a ) {
			var b = 4;
			var c = a.length / 4;
			var d = c + 6;
			var w = new Array( b * ( d + 1 ) );
			var e = new Array( 4 );
			
			for( var i = 0; i < c; i++ )
			{
				var r = [a[4*i], a[4*i+1], a[4*i+2], a[4*i+3]];
				w[i] = r;
			}
			
			for( var i = c; i < ( b * ( d + 1 ) ); i++ )
			{
				w[i] = new Array( 4 );
				
				for( var t = 0; t < 4; t++ )
				{
					e[t] = w[i-1][t];
				}
				
				if( i % c == 0 )
				{
					e = SubWord( RotWord( e ) );
					for( var t = 0; t < 4; t++ )
					{
						e[t] ^= Rcon[i/c][t];
					}
				}
				else
				{
					if( c > 6 && i % c == 4 )
					{
						e = SubWord( e );
					}
				}
				
				for( var t = 0; t < 4; t++ )
				{
					w[i][t] = w[i-c][t]^e[t];
				}
			}
			
			return w;
		};


		// apply SBox to 4-byte word w
		function SubWord( w )
	    {
			for( var i = 0; i < 4; i++ ) 
			{
				w[i] = Sbox[w[i]];
			}
			
			return w;
		};


		// rotate 4-byte word w left by one byte
		function RotWord( w ) 
		{
			var a = w[0];
			for( var i = 0; i < 3; i++ ) 
			{
				w[i] = w[i+1];
			}			
			w[3] = a;
			
			return w;
		};


		// 
		// Encrypt a text using AES encryption in Counter mode of operation
		// see http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf 
		//
		// Unicode multi-byte character safe
		//
		// @param {String} a   Source text to be encrypted
		// @param {String} b   The password to use to generate a key
		// @param {Number} c   Number of bits to be used in the key (128, 192, or 256)
		// @returns {string}         Encrypted text
		//
		this.AESEncryptCtr = function( a, b, c ) {
			var d = 16;                                 // block size fixed at 16 bytes / 128 bits (Nb=4) for AES
			if( !( c == 128 || c == 192 || c == 256 ) ) // standard allows 128/192/256 bit keys
		    {
				return "";
			}
			
			a = a.encodeUTF8();
			b = b.encodeUTF8();

			//
			// use AES itself to encrypt password to get cipher key (using plain password as source for key 
			// expansion) - gives us well encrypted key
			//
			var e = c / 8;
			
			var f = new Array( e );
			for(var i=0;i<e;i++) {
				f[i] = isNaN( b.charCodeAt( i ) ) ? 0 : b.charCodeAt( i );
			}
			
			var g = Cipher( f, KeyExpansion( f ) );
			g = g.concat( g.slice( 0, e - 16 ) );

			//
			// initialise counter block (NIST SP800-38A §B.2): millisecond time-stamp for nonce in 1st 8 bytes,
			// block counter in 2nd 8 bytes
			//      
			var h = new Array( d );
			var j = ( new Date() ).getTime();
			var k = Math.floor( j / 1000 );
			var l = j % 1000;

			// encode nonce with seconds in 1st 4 bytes, and (repeated) ms part filling 2nd 4 bytes
			for( var i = 0; i < 4; i++ ) 
			{
				h[i] = ( k >>> i * 8 ) & 255;
			}
			for( var i = 0; i < 4; i++ ) 
			{
				h[i+4] = l & 255;
			}

			// and convert it to a string to go on the front of the ciphertext
			var m = "";
			for( var i = 0; i < 8; i++ ) 
			{
				m += String.fromCharCode( h[i] );
			}

			// generate key schedule - an expansion of the key into distinct Key Rounds for each round
			var n = KeyExpansion( g );
			var o = Math.ceil( a.length / d );
			var p = new Array( o ); // ciphertext as array of strings
			
			for( var q = 0; q < o; q++ ) 
			{
				for( var r = 0; r < 4; r++ ) 
				{
					h[15-r] = ( q >>> r * 8 ) & 255;
				}

				//
				// set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
				// done in two stages for 32-bit ops: using two words allows us to go past 2^32 blocks (68GB)
				//
				for( var r = 0; r < 4; r++ ) 
				{
					h[15-r-4] = ( q / 4294967296 >>> r * 8 );
				}

				// -- encrypt counter block --
				var s = Cipher( h, n );

				// -- xor plaintext with ciphered counter char-by-char --
				var t = q < o-1 ? d : ( a.length- 1 ) % d + 1;
				var u = new Array( t );
				for( var i = 0; i < t; i++ )
				{
					u[i] = s[i] ^ a.charCodeAt( q * d + i );
					u[i] = String.fromCharCode( u[i] );
				}
				
				p[q] = u.join( "" );
				
			}

			//
			// Finally, joion blocks to create output string.
			// Array.join is more efficient than repeated string concatenation in IE
			//
			var v = m + p.join( "" );

			// Encode in base 64 (modified) so that it may be passed inX XML & URLs
			v = v.encodeBase64();
			v = v.replace( /\+/g, "-" );
			v = v.replace( /\//g, "_" );
			v = v.replace( /=/g, "," );

			// return the result string.
			return v;
		};

		// 
		// Decrypt a text encrypted by AES in counter mode of operation
		// see http://csrc.nist.gov/publications/nistpubs/800-38a/sp800-38a.pdf 
		//
		// Unicode multi-byte character safe
		//
		// @param {String} a   Source text to be encrypted
		// @param {String} b   The password to use to generate a key
		// @param {Number} c   Number of bits to be used in the key (128, 192, or 256)
		// @returns {String}   Decrypted text
		//
		this.AESDecryptCtr = function( a, b, c )  
		{
			var d = 16;    // block size fixed at 16 bytes / 128 bits (Nb=4) for AES

			if( !( c == 128 || c == 192 || c == 256 ) ) // standard allows 128/192/256 bit keys
			{
				return "";
			}

			// Decode the base64 cryptext into the binary format.
			a = a.replace( /\-/g, "+" );
			a = a.replace( /_/g, "/" );
			a = a.replace( /\,/g, "=" );
			a = a.decodeBase64();

			// Translate from the UTF-8 encoding.
			b = b.encodeUTF8();

			// use AES to encrypt password (mirroring encrypt routine)
			var e = c / 8;
			var f = new Array( e );
			
			for( var i = 0; i < e; i++ ) 
			{
				f[i] = isNaN( b.charCodeAt( i ) ) ? 0 : b.charCodeAt( i );
			}

			// generate key schedule - an expansion of the key into distinct Key Rounds for each round
			var g = Cipher( f, KeyExpansion( f ) );
			g = g.concat( g.slice( 0, e - 16 ) ); // expand key to 16/24/32 bytes long

			// recover nonce from 1st 8 bytes of ciphertext
			var h = new Array( 8 );
			var ctrTxt = a.slice( 0, 8 );
			for( var i = 0; i < 8; i++ ) 
			{
				h[i] = ctrTxt.charCodeAt( i );
			}

			// generate key schedule
			var j = KeyExpansion( g );

			// separate ciphertext into blocks (skipping past initial 8 bytes)
			var k = Math.ceil( ( a.length - 8 ) / d );
			var l=new Array( k );
			for( var m = 0; m < k; m++ ) 
			{
				l[m] = a.slice( 8 + m * d, 8 + m * d + d );
			}
			
			a = l;  // ciphertext is now array of block-length strings

			// plaintext will get generated block-by-block into array of block-length strings
			var n = new Array( a.length );
			for( var m = 0; m < k; m++ ) 
			{
				// set counter (block #) in last 8 bytes of counter block (leaving nonce in 1st 8 bytes)
				for( var o = 0; o < 4; o++ ) 
				{
					h[15-o] = ( ( m ) >>> o * 8 ) & 255;
				}
				
				for( var o = 0; o < 4; o++ ) 
				{
					h[15-o-4] = ( ( ( m + 1 ) / 4294967296 - 1 ) >>> o * 8 ) & 255;
				}

				var p = Cipher( h, j );  // encrypt counter block

				// -- xor cryptext with ciphered counter byte-by-byte --
				var q = new Array( a[m].length );
				
				for( var i = 0; i < a[m].length; i++ ) 
				{
					q[i] = p[i] ^ a[m].charCodeAt( i );
					q[i] = String.fromCharCode( q[i] );
				}
				
				n[m] = q.join( "" );
			}

			// join array of blocks into single plaintext string
			var r = n.join( "" );

			// decode from UTF8 back to Unicode multi-byte chars
			r = r.decodeUTF8();

			// return string.
			return r;
		}
	};

	//
	// These pointers hold the helper functions: AES, RSA, and SHA-1. 
	// The latter two are loaded dynamically in the init phase due to code size.
	//
	var aesFuncs = new bbSecureAjaxAESHelper();
	var rsaFuncs = null;
	var sha1Funcs = null;

	//
	// Create the standard XMLHTTPRequest object. 
	// a new object instance is returned for each invocation (allows simultaneous requests)
	//
	function createXHRObject() 
	{
		if( typeof XMLHttpRequest != "undefined" ) 
		{
			// Safari, Opera, Mozilla
			return new XMLHttpRequest();
		} 
		else if( typeof ActiveXObject != "undefined" ) 
		{
			// Internet explorer.
			return new ActiveXObject( "Microsoft.XMLHTTP" );
		} 
		else 
		{
			// Otherwise, we can't get it.
			throw new Error( "XMLHttpRequest not supported" );
		}
	};

	//
	// Trim whitespace from around a string. 
	//
	function trim( str )
	{
		return str.replace( /^\s+|\s+$/g, "" );
	};

	//
	// Gets the text inside a node (DOM or XML node) in a cross-browser way.
	//
	function getTextNode( element ) 
	{
		var returnedText = ""; // by default, if error, we return an empty string.
		if( element )
		{	
			if( element.textContent ) 
			{
				returnedText = element.textContent;
			} 
			else if( element.text ) 
			{
				returnedText = element.text;
			}
			
			if( returnedText.indexOf( "[CDATA[" ) > -1 ) 
			{
				returnedText = returnedText.substring( 7 );
			}
			
			if( returnedText.lastIndexOf( "]]" ) > -1 ) 
			{
				returnedText = returnedText.substring( 0, returnedText.lastIndexOf( "]]" ) );
			}
		}
		
		return returnedText;
	};

	//
	// Parse an XML string into a Document object
	//
	function parseXML(xmlData) {
		if(window.ActiveXObject) {
			var xmlDoc=new ActiveXObject("Microsoft.XMLDOM");
			xmlDoc.async="false";
			xmlDoc.loadXML(xmlData);
			return xmlDoc;
		} else if(document.implementation && document.implementation.createDocument) {
			var p=new DOMParser();
			var xmlDoc=p.parseFromString(xmlData,"text/xml");
			return xmlDoc;
		}
	};

	//
	// Send an AJAX request to <application> using POST method, and passing <parms>
	// when the response is received, the callback <callbackFn> is called with the 
	// http status, and the XML response document.
	//
	function sendAjax(apiName,params,callbackFn) {
		var xhrObject=createXHRObject();
		xhrObject.open("POST",apiName,true);
		xhrObject.onreadystatechange=function() {
			if(xhrObject.readyState==4) {
				callbackFn(xhrObject.status,xhrObject.responseXML);
			}
		};

		xhrObject.setRequestHeader("Content-type","application/x-www-form-urlencoded");
		xhrObject.setRequestHeader("Content-length",params.length);
		xhrObject.setRequestHeader("Connection","close");
		xhrObject.send(params);
	};

	//
	// Sign a message with SHA-1 and RSA. 
	//
	//  The cryptoligic hash is taken of the incoming string, using SHA-1 and the resulting
	// hash is then encoded using the RSA key assigned to this session. The resulting string
	// of blocks is returned.
	//
	function signMessage(messageToSign) {
		return encodeRSA(serverPublicKey,sha1Funcs.hexSHA1(messageToSign));
	};

	//
	// Prove that an incoming message has not been tampered with.
	//
	//  The signature of the incoming message, as reported by the server is decrypted using
	// the RSA key of the current session. The decrypted signature is then compared to the 
	// SHA-1 hash of the message. If they are the same, the the method returns true, else it
	// returns false.
	//
	function proveSignature(signature,message){
		var sign2=decodeRSA(serverPublicKey,signature);
		var hash=sha1Funcs.hexSHA1(message);
		if(hash==sign2) {
			return true;
		}
		return false;
	};

	//
	// Wrapper function for RSA libaray. 
	//
	//   Takes a key structure and generates an RSAKey object. Then, using the key,
	// encrypt the incoming message.
	//
	function encodeRSA(key,message) {
		key=rsaFuncs.makeRSAKey(key.exp,"00",key.mod);
		return rsaFuncs.RSAEncryptString(key,message);
	};

	//
	// Wrapper function for RSA library
	//
	//   Takes a key structure and generates an RSAKey object. Then, using the key,
	// decrypt the incoming message.
	//
	function decodeRSA(key,cryptext) {
		key=rsaFuncs.makeRSAKey("00",key.exp,key.mod);
		return rsaFuncs.RSADecryptString(key,cryptext);
	};

	//
	// Wrapper function for AES encrypt.
	//
	function encodeAES(message) {
		return aesFuncs.AESEncryptCtr(message,sharedSecretKey,256);
	};

	//
	// Wrapper function for AES decrypt
	//
	function decodeAES(cryptext) {
		return aesFuncs.AESDecryptCtr(cryptext,sharedSecretKey,256);
	};

	//
	// Perform initialization of SecureAjax object.
	//
	// Load the RSA and SHA-1 JavaScript code using the specified key. Once loaded, perform
	// a Diffie-Hellman key exchange to generate a random AES key for the current session.
	//
	function doInit() {
		// Send a request to the main script to prepare the helper portoion (RSA/SHA1/BigInt)
		sendAjax(serverURL+"secureajax.js.php","action=helper",function(stt,doc) {
			// If we get a response node, we're good
			if(doc.getElementsByTagName('response')[0]) {
				// Get the script contents.
				var scr=getTextNode(doc.getElementsByTagName('response')[0]);
				// and de-crypt them
				scr=aesFuncs.AESDecryptCtr(scr,scriptDecodeKey,256);
				// Finally, execute the script to install the helpers (they will call the public API setHelpers)
				if(scr.indexOf('text/javascript')>0) {
					eval(scr);
				} else {
					// If it didn't decode properly, indicate error.
					channelReadyCallbackFn(false);
				}
			} else {
				// If we didn't get a response node, indicate error.
				channelReadyCallbackFn( false );
			}
		}
		);
		
		// Finally, after they are installed, let's get our session key.
		that.getSecretKeyDH();
	};

	//
	// Set the internal object instances for the RSA and SHA-1 classes. Called by the 
	// javaScript code retreieved and eval'ed in the doInit method. 
	//
	function doSetHelpers(key,rsahelper,sha1helper){
		// Make sure the key was the same (prelimenary security check)
		if(key==scriptDecodeKey){
			// Set the object references.
			rsaFuncs=rsahelper;
			sha1Funcs=sha1helper;
		}
	};

	//
	// Perform the initial Diffie-Hellman key exchange. This allows us to generate a
	// private AES key that is completely random, and is hidden from the outside world 
	// (even if the source code is expanded and inspected).
	//
	function doGetDHKey(){
		DHNegotiationInProgress=true;
		
		// If the helpers haven't ben installed yet, then set a timer to try again.
		if(null==rsaFuncs||null==sha1Funcs) {
			setTimeout('window.secureAjax.getSecretKeyDH();',100);
			return;
		}

		// Get a cryptologically secure random number (based on PRNG)
		var randomExponent=rsaFuncs.makeRandomKey(16);

		//
		// Using the server's challenge token (sent in with the script initially) generate the shared
		// secret key.
		//
		var sharedSecretStr=rsaFuncs.getDHSecret(diffieHellman.msg,diffieHellman.mod,randomExponent);

		//
		// Using the generator and modulus, as well as the random key... generate a response message to
		// the server.
		//
		var messageToSign=rsaFuncs.getDHSecret(diffieHellman.gen,diffieHellman.mod,randomExponent);

		//
		// Sign the response message with our RSA key. This will ensure no man-in-the-middle attacks
		// on our key.
		//
		var signature=signMessage(messageToSign);

		// 
		// Send the challenge response back to the server, so the server knows the secret key.
		//
		var params="msg="+messageToSign+"("+signature+")";
		sendAjax('/dhkeyserver.php',params,function(stt,doc) {
			//
			// If the server indicates success (i.e. no tampering) then set the flags
			// and call the callback sent to us by the login class.
			//
			if(doc.getElementsByTagName('success')[0]) {
				sharedSecretKey=sha1Funcs.hexSHA1(sharedSecretStr);
				DHNegotiationInProgress=false;
				if(null!=channelReadyCallbackFn) {
					channelReadyCallbackFn(true);
				}
			} else {
				//
				// Else, if there was an error, notify the user, and the callback of the error.
				//
				alert("Error in setting up secure communication.");
				if(null!=channelReadyCallbackFn) {
					channelReadyCallbackFn(false);
				}
			}
		});
	};

	//
	// Perform re-negotiation of AES session key by the application using Diffie-Hellman method.
	//
	function doGetNewKey(callbackFn) {
		//
		// Set the flag so that isReady reports false.
		//
		DHNegotiationInProgress=true;

		//
		// Null check for the required RSA and SHA-1 objects.
		//
		if(null==rsaFuncs||null==sha1Funcs) {
			DHNegotiationInProgress=false;
			callbackFn(false);
			return;
		}

		// Generate a new cryptologically secure random number.
		var randomExponent=rsaFuncs.makeRandomKey(16);

		//
		// Using the generator and modulus, as well as the random key... generate a response message to
		// the server.
		//
		var messageToSign=rsaFuncs.getDHSecret(diffieHellman.gen,diffieHellman.mod,randomExponent);

		//
		// Sign the response message with our RSA key. This will ensure no man-in-the-middle attacks
		// on our key.
		//
		var signature=signMessage(messageToSign);

		// 
		// Send the challenge response back to the server, so the server knows the secret key.
		//
		var params="newmsg="+newMessageStr+"("+signature+")";
		sendAjax('/dhkeyserver.php', params, function(stt,doc) {

			if(doc.getElementsByTagName('response').length>0) {

				// 
				//  Parse the message (split the response and signature)
				//
				var message=getTextNode(doc.getElementsByTagName('response')[0]);
				message=trim(message);
				var signature="";
				var idx1=message.indexOf("(");
				if(idx1>-1) {
					var idx2=message.lastIndexOf(")");
					signature=message.substring(idx1+1,idx2);
					message=message.substring(0,idx1);
				}

				// 
				// Prove the message has not been changed in transit (decrypt the RSA signature, and compare signature and message)
				//
				if(proveSignature(signature,message)==true) {
					//
					// If good, generate the shared secret, create the AES key, and set the success flag.
					//
					var sharedSecretStr=rsaFuncs.getDHSecret(message,diffieHellman.mod,randomExponent);
					sharedSecretKey=sha1Funcs.hexSHA1(sharedSecretStr);
					DHNegotiationInProgress=false;
					//
					// Finally, indicate success to the callback
					//
					if(null!=callbackFn) {
						callbackFn(true);
					}
					return;
				} else {
					alert("Error in negotiating new key. Message was altered");
				}
			} else {
				alert("Error in negotiating new key. Invalid response from server.");
			}
			
			if(null!=callbackFn) {
				callbackFn(false);
			}
			
			DHNegotiationInProgress=false;
		});
	};

	//
	// Main method for secure AJAX communication. 
	//
	// Call the specified service, passing the POST parameters in an encrypted and
	// signed format. Pass the unencrypted XML response back to the callback function. 
	// passes a null document on error.
	//
	function doSendSecure(serviceUrl,parms,callback){
		// If we do not have a key set, report an error.
		if(null==sharedSecretKey) {
			alert('Secure communications not set up.');
			callback(null);
			return;
		}

		// Encrypt and sign the message parameters.
		var encodedMsg=encodeAES(parms);
		var signature=signMessage(encodedMsg);
		var params="msg="+encodedMsg+"("+signature+")";

		//	Send the message to the specified web service
		sendAjax(serviceUrl,params,function(stt,doc) {
			//
			// If we get back a proper document, look for the response tag.
			// doc will never be NULL at this point.
			//
			if(doc.getElementsByTagName('response').length>0) {
				
				// The encrypted response will be in the text of the response node.
				var cryptext=getTextNode(doc.getElementsByTagName('response')[0]);
				cryptext=trim(cryptext);
				
				// Extract the signature of the message.
				var signature="";
				var idx1=cryptext.indexOf("(");
				if(idx1>-1) {
					var idx2=cryptext.lastIndexOf(")");
					signature=cryptext.substring(idx1+1,idx2);
					cryptext=cryptext.substring(0,idx1);
				}

				// If the signature proves the message has not been tampered with...
				if(proveSignature(signature,cryptext)==true) {
					
					// Decrypt the resulting XML document
					var plaintext=decodeAES(cryptext);
					var doc=parseXML(plaintext);
					
					// If the response node was an error message from the server, notify the user.
					if(doc.getElementsByTagName('error').length>0){
						alert(getTextNode(doc.getElementsFromTagName('error')[0]));
					}
					
					// pass the document back to the caller.
					callback(doc);
				} else {
					alert("Error: Message has been interfered with. Signatures do not match.");
					callback(null);
				}
			} else {
				alert("Error: Invalid response from server.");
				callback(null);
			}
		});
	};

	//
	// Load a JavaScript from the SecureAjaxAPIs webservice. 
	//
	// Takes a callback, as the public API can do one of 2 things with the script: eval it or
	// insert it into the DOM as a script node.
	//
	function doLoadScpt(scriptname,id,reqScr,callback){
		var msg="<loadScript name='"+scriptname+"'/>";
		if(id==null||id==""){
			id=scriptDependencyCache.length+1;
		}
		scriptDependencyCache[id]=false;
		doSendSecure(serverURL+"SecureAjaxAPIs.php",msg,function(doc){
			if(doc!=null){
				var scr=doc.getElementsByTagName('script')[0];
				if(scr&&scr.getAttribute('type')){
					var t=scr.attributes.getNamedItem('type').value;
					if(t.indexOf('text/javascript')>-1){
						if(requiredScriptsLoaded(reqScr)){
							callback(getTextNode(scr));
							scriptDependencyCache[id]=true;
							checkForScriptsReady();
						}else{
							scriptDependencyCache[id]={
									req:reqScr,text:getTextNode(scr),callback:callback};
						}
					}
				}
			}
		});
	};


	function checkForScriptsReady(){
		for(var i in scriptDependencyCache){
			if(scriptDependencyCache[i]!==true&&scriptDependencyCache[i]!==false){
				if(requiredScriptsLoaded(scriptDependencyCache[i].req)){
					scriptDependencyCache[i].callback(scriptDependencyCache[i].text);
					scriptDependencyCache[i]=true;
				}else{
					setTimeout(checkForScriptsReady,250);
				}
			}
		}
	};

	function requiredScriptsLoaded(req){
		if(req===null||req==""){
			return true;
		}
		var requiredScriptIds=req.split(' ');
		var foundScript=false;
		for(var i=0;i<requiredScriptIds.length;++i){
			if(scriptDependencyCache[requiredScriptIds[i]]!==true){
				foundScript=true;
				break;
			}
		}
		return (foundScript==false);
	};

	function scriptStillLoading(){
		var foundScript=false;
		checkForScriptsReady();
		for(var i in scriptDependencyCache){
			if(scriptDependencyCache[i]!==true){
				foundScript=true;
				break;
			}
		}
		return foundScript;
	};

	function getScriptCacheIds(){
		var keys="";
		for(var i in scriptDependencyCache){
			keys+=i+" ";
		}
		return trim(keys);
	};

	//
	// Load an image from the server, and insert it into the DOM, replacing the node <target> as
	// a DATA URL. 
	//
	// NOTE: Does not work with IE7 and earlier...
	//
	function doLoadImageFromServer(imgname,target){
		var msg="<loadImage name='"+imgname+"'/>";
		doSendSecure("<?php print($secureAjaxConfig['APIBASEURL']);?>SecureAjaxAPIs.php",msg,function(doc){
			if(doc!=null){
				var scr=doc.getElementsByTagName('img')[0];
				var type=scr.attributes.getNamedItem('mimetype').value;
				var data=getTextNode(scr);
				document.getElementById(target).src="data:"+mimetype+";
				base64,"+base64rep;
			}
		});
	};

	//
	// Load a stylesheet from the SecureAjaxAPIs webservice, and isert it into the head of the document.
	//
	function doLoadStyle(scriptname){
		var msg="<loadStyle name='"+scriptname+"'/>";
		doSendSecure(serverURL+"SecureAjaxAPIs.php",msg,function(doc){
			if(doc!=null){
				var scr=doc.getElementsByTagName('script')[0];
				if(scr&&scr.getAttribute('type')){
					var t=scr.attributes.getNamedItem('type').value;
					if(t.indexOf('text/css')>-1){
						// prepare the new style DOM node.
						var s=document.createElement('style');
						s.setAttribute("type","text/css");
						s.setAttribute("saexec","no");

						// Get the contents from the input message.
						var st=getTextNode(scr);

						// now, IE does things differently than other browsers, so we have do do this
						// to actually insert the style text.
						if(s.styleSheet){
							s.styleSheet.cssText=st;
						}else{
							s.appendChild(document.createTextNode(st));
						}
						document.getElementsByTagName('head')[0].appendChild(s);
					}
				}
			}else{
				alert("Error: Invalid response from server.");
			}
		});
	};

	//
	// Insert a JavaScipt at a particular location in the DOM.
	//
	// @param {string} scr - The text of the JavaScript.
	// @param {Node} p - the parent DOM node that we will insert the script into.
	// @param {Node} e - If not null, the DOM node we will insert the script node before.
	//
	function insScrptAt(scr,p,e){
		var s=document.createElement('script');
		s.setAttribute("type","text/javascript");
		s.text=scr;
		p.insertBefore(s,e);
	};

	//
	// Load a complet web page from the SecureAjaxAPIs webservice.
	//
	//   Load an HTML page from the server securely, then process the head and body
	// for stylesheets and JavaScripts that need to be handled. This is needed as 
	// innerHTML won't processes these items as they are inserted.
	//   Also, if an onLoad attribute is set on the body, eval the code when we're all done. 
	//
	function doLoadPage(pagename){
		var msg="<loadPage name='"+pagename+"'/>";
		doSendSecure(serverURL+"SecureAjaxAPIs.php",msg,function(doc){
			if(doc!=null){
				var scr=doc.getElementsByTagName('document')[0];
				if(scr){
					// process the head. We only care about link, style, and script tags.
					insHdrScr(scr.getElementsByTagName('head')[0]);

					// Set the body HTML. This method is faster than building the nodes, or document.write.
					document.body.innerHTML = getTextNode(scr.getElementsByTagName('body')[0]);

					// But we have the side-effect of not running JavaScripts that are embedded.
					runScripts(document.body);

					// Now, if he body has an onLoad script, execute it.
					if(scr.getElementsByTagName('body')[0].getAttribute('onLoad')){

						// IF scripts are still loading, put the script in the scriptDependencyCache
						var contents = scr.getElementsByTagName('body')[0].getAttribute('onLoad');
						if(scriptStillLoading()){
							scriptDependencyCache['body_onload']={
									req:getScriptCacheIds(), text:contents, callback:function(scr){
										eval(scr);
									}
							};

						}else{
							eval(contents);
						}
					}
				}
			}
		});
	};

	//
	// Process the incoming Node structure and insert the appropriate nodes into the 
	// document header. This clears the original contents of the header as well.
	//
	function insHdrScr(src){
		// get a pointer to the head node.
		var hdr=document.getElementsByTagName('head')[0];

		// Delete all child elements in the head if any.
		if(hdr.hasChildNodes()){
			while(hdr.childNodes.length>=1){
				hdr.removeChild(hdr.firstChild);
			}
		}

		// If there are no new scripts, leave it with an empty head.
		if(!src){
			return;
		}

		// Now, non-rendering nodes (like scripts, and styles, etc.) will not
		// process with innerHTML unless a rendering node is inserted first. This
		// is a quick and easy way to turn the incoming string representation of the 
		// node structure into DOM nodes that we can iterate across..
		//
		var dn=document.createElement('div');
		dn.innerHTML="<div>&nbsp;</div>"+getTextNode(src);

		// Iterate across all nodes. There won't be any inner nodes, so no recursion is needed.
		var n=dn.firstChild;
		while(n){
			if(n.nodeType==1){
				var s=null;
				if(n.tagName.toLowerCase()=='script'){
					s=createScriptNode(n,hdr,null);
				}else if(n.tagName.toLowerCase()=='style'){
					if(!n.getAttribute("saexec")){
						// Create the style node.
						s=document.createElement('style');
						s.setAttribute("type","text/css");
						var st=getTextNode(n);

						// Get the text to place in it.
						if(!st)st=n.innerHTML;

						// Then insert the text into the style node (cross-browser)
						if(s.styleSheet){
							s.styleSheet.cssText=st;
						}else{
							s.appendChild(document.createTextNode(st));
						}
					}
				} else if(n.tagName.toLowerCase()=='link') {
					// Process a link node (loaded stylesheet)
					s=document.createElement('link');
					if(n.getAttribute('type')){
						s.type =n.type;
					}
					if(n.getAttribute('media')){
						s.media=n.media;
					}
					if(n.getAttribute('rel')){
						s.rel=n.rel;
					}
					if(n.getAttribute('href')){
						//
						// Check to see if the stylesheet is to be loaded by SecureAjax or 
						// directly by the browser.
						//
						var src=n.href;
						var strt = src.indexOf("secure://");
						if(strt==0){
							// If loaded by SecureAjax, make the server call
							doLoadStyle(src.substring(strt+9));
							s=null;
						}else{
							// Else, if it's external, just set the src.
							s.setAttribute("src",src);
						}
					}
				}

				// If we have a node to insert into the head, do so.
				if(s!=null){
					hdr.appendChild(s);
					s=null;
				}
			}

			// continue iteration...
			n=n.nextSibling;
		}
	};

	//
	// Run any embedded javaScripts that are in the body of the document.
	//
	// recursively check the body nodes of the document, and if a script is found,
	// re-add it (above the current node) so that the browser will execute it. Also
	// allow scripts to be loaded externally.
	//
	function runScripts(e){
		if(e.nodeType!=1){
			return;
		}
		if(e.tagName.toLowerCase()=='script'){
			s=createScriptNode(e,e.parentNode,e);
			if(s!=null){
				e.parentNode.insertBefore(s,e);
			}
		}else{
			var n=e.firstChild;
			while(n){
				if(n.nodeType==1){
					runScripts(n);
				}
				n=n.nextSibling;
			}
		}
	};

	function createScriptNode(n,insrt,instbef){
		var s=document.createElement('script');
		s.setAttribute("type","text/javascript");
		if(n.getAttribute('src')){
			var src=n.getAttribute('src');
			var strt=src.indexOf("secure://");
			if(strt==0){
				var id=n.getAttribute('id');
				var req=n.getAttribute('required');
				doLoadScpt(src.substring(strt+9),id,req,function(scr){
					insScrptAt(scr,insrt,instbef);
				}
				);
				s=null;
			}else{
				s.setAttribute("src",src);
				var id=n.getAttribute('id');
				if(id){
					scriptDependencyCache[id]=true;
				}
			}
		}else{
			s.text=getTextNode(n);
			var id=n.getAttribute('id');
			if(id){
				scriptDependencyCache[id]=true;
			}
		}
		return s;
	};

	//
	// PUBLIC API for SecureAjaxLayer. This hides the implementation of the secure methods
	// from DOM inspectors like the IE debug tool and Firebug. We don't want to give out any
	// secrets we don't have to.
	//

	this.getSecretKeyDH=function(){
		doGetDHKey();
	};

	this.getNewSecureKey=function(callbackFn){
		doGetNewKey(callbackFn);
	};

	this.isReady=function(){
		return(DHNegotiationInProgress==false);
	};

	this.setReadyCallback=function(func){
		if(func){
			channelReadyCallbackFn=func;
		}
	};

	this.sendSecureMessage=function(serviceUrl,parms,callback){
		doSendSecure(serviceUrl,parms,callback);
	};

	this.insertScript=function(scrptname,divid,id,required){
		id=((id)?id:"");
		required=((required)?required:"");
		doLoadScpt(scrptname,id,required,function(scr){
			insScrptAt(scr,document.getElementById(divid),null);
		});
	};

	this.execScript=function(scrptname){
		doLoadScpt(scriptname,null,null,function(scr){
			eval(scr);
		});
	};

	this.loadStylesheet=function(scrptname){
		doLoadStyle(scrptname);
	};

	this.loadImage=function(imgname,target){
		doLoadImageFromServer(imgname,target);
	};

	this.loadPage=function(pagename){
		doLoadPage(pagename);
	};

	this.setHelpers=function(key,rsahelper,sha1helper){
		doSetHelpers(key,rsahelper,sha1helper);
	};

	this.init=function(){
		doInit();
	}
};

self.top.secureAjax=new bbSecureAjaxLayer();
